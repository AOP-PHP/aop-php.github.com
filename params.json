{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"AOP","tagline":"Aspect Oriented Programming on PHP","body":"# Introduction #\r\n\r\nAOP is a PECL extension that enables you to use Aspect Oriented Programming in PHP, without the need\r\nto compile or proceed to any other intermediate step before publishing your code.\r\n\r\nThe AOP extension is designed to be the easiest way you can think of for integrating AOP to PHP.\r\n\r\nAOP aims to allow separation of cross-cutting concerns (cache, log, security, transactions, business rules, ...)\r\n\r\n[![Build Status](https://secure.travis-ci.org/Juliens/AOP.png?branch=master)](http://travis-ci.org/Juliens/AOP)\r\n\r\n## PHP's AOP extension history ##\r\n\r\nThe AOP extension is a project which started a while ago even if its development is quite very new (early 2012). It was\r\nfirst expected to be a fully PHP developed library, as part of a dependency injection framework. The Aspect Oriented\r\nProgramming implementation would have taken the form of auto generated proxies.\r\n\r\nThat was before Julien Salleyron, the lead developer of the project, wanted to take it to the next level while writing\r\nthe AOP core features as a PHP's extension.\r\n\r\nGérald Croës also belongs to the initial team, mainly in charge of the documentation and discussions around\r\nthe extension's API.\r\n\r\n## Installation ##\r\n\r\nDownload the AOP from github, compile and add the extension to your php.ini\r\n\r\n```sh\r\n    #Clone the repository on your computer\r\n    git clone https://github/juliens/AOP\r\n    cd AOP\r\n    #prepare the package, you will need to have development tools for php\r\n    phpize\r\n    #compile the package\r\n    ./configure\r\n    make\r\n    #before the installation, check that it works properly\r\n    make test\r\n    #install\r\n    make install\r\n```\r\n\r\nNow you can add the following line to your php.ini to enables AOP\r\n\r\n```ini\r\n    extension=AOP.so\r\n```\r\n\r\n## What is AOP ? Basic tutorial ##\r\n\r\nLet's assume the following class\r\n\r\n``` php\r\n<?php\r\n    class MyServices\r\n    {\r\n       public function doAdminStuff1 ()\r\n       {\r\n          //some stuff only the admin should do\r\n          echo \"Calling doAdminStuff1\";\r\n       }\r\n\r\n       public function doAdminStuff2 ()\r\n       {\r\n          //some stuff only the admin should do\r\n          echo \"Calling doAdminStuff2\";\r\n       }\r\n    }\r\n```\r\n\r\nNow you want your code to be safe, you don't want non admin users to be able to call doAdminMethods.\r\n\r\nWhat are your solutions ?\r\n\r\n*    Add some code to check the credentials \"IN\" you MyServices class. The drawback is that it will pollute your\r\ncode, and your core service will be less readable.\r\n*    Let the clients have the responsibility to check the credentials when required. The drawbacks are that you will\r\nduplicate lots of code client side if you have to call the service from multiple places\r\n*    Add some kind of credential proxy that will check the credentials before calling the actual service. The drawbacks\r\nare that you will have to write some extra code, adding another class on the top of your services.\r\n\r\nMoreover, those solutions tends to increase in complexity while you are adding more cross-cutting concerns like\r\ncaching or logging.\r\n\r\nThat's where AOP comes into action as you will be able to tell PHP to do some extra actions while calling your\r\nMyServices's admin methods.\r\n\r\nSo let's first write the rule needed to check if we can or cannot access the admin services.\r\n\r\n``` php\r\n<?php\r\n    function adviceForDoAdmin ()\r\n    {\r\n       if ((! isset($_SESSION['user_type'])) || ($_SESSION['user_type'] !== 'admin')) {\r\n          throw new Exception('Sorry, you should be an admin to do this');\r\n       }\r\n    }\r\n```\r\n\r\nDead simple : we check the current PHP session to see if there is something telling us the current user is an admin (Of\r\ncourse we do realize that you may have more complex routines to do that, be we'll keep this for the example)\r\n\r\nNow, let's use AOP to tell PHP to execute this method \"before\" any execution of admin methods.\r\n\r\n``` php\r\n<?php\r\n    aop_add_before('MyServices::doAdmin*', 'adviceForDoAdmin');\r\n```\r\n\r\nNow, each time you'll invoke a method of an object of the class MyServices, starting by doAdmin, AOP will launch the function\r\nbasicAdminChecker *before* the called method.\r\n\r\nThat's it, simple ain't it ?\r\n\r\nNow le's try the examples :\r\n\r\n``` php\r\n<?php\r\n    //session is started and we added the above examples to configure MyServices & basicAdminChecker\r\n\r\n    $services = new MyServices();\r\n    try {\r\n       $services->doAdminStuff1();//will raise an exception as nothing in the current session tells us we are an admin\r\n    } catch (Exception $e) {\r\n       echo \"You cannot access the service, you're not an admin\";\r\n    }\r\n\r\n    $_SESSION['user_type'] = 'admin';//again, this is ugly for the sake of the example\r\n\r\n    try {\r\n       $service->doAdminStuff1();\r\n       $service->doAdminStuff2();\r\n    } catch (Exception $e) {\r\n       //nothing will be caught here, we are an admin\r\n    }\r\n```\r\n\r\nHere you are, you know the basics of AOP.\r\n\r\n## AOP Vocabulary and PHP's AOP capabilities ##\r\n\r\n### Advice ###\r\n\r\nAn advice is a piece of code that can be executed. In our first example, the function adviceForAdmin is an advice, it\r\n*could* be executed.\r\n\r\nIn PHP's AOP extension, an advice can be a trait, a callback, an anonymous function, a static method of a class,\r\na method of a given object or a closure.\r\n\r\n### Join points ###\r\n\r\nJoin points are places where we can attach advices.\r\n\r\nIn PHP's AOP extension, a join point can be:\r\n\r\n*    before any method / function call\r\n*    after any method / function call\r\n*    around any method / function call\r\n*    During the arousing of an exception of any method / function\r\n*    after any method / function call, should the method terminate normally or not (triggers an exception or not)\r\n\r\nIn our first example, we used a \"before\" join point.\r\n\r\n### Pointcut ###\r\n\r\nPointcuts are a way to describe whether or not a given join point will trigger the execution of an advice.\r\n\r\nIn PHP's AOP extension, pointcuts can be configured with a quite simple and straightforward syntax.\r\n\r\nIn our first example the pointcut was \"MyServices::doAdmin*\" and was configured to launch the advice \"before\" the\r\nexecution of the matching methods join points.\r\n\r\n## Why or should I use AOP? ##\r\n\r\nAOP is a whole different way of thinking for developing application. It is as different as object oriented programming\r\n can be opposed to procedural programming.\r\n\r\nEvent if you don't want to base your future development on this approach, you may find it very useful for debugging\r\npurposes. Imagine a world where you can debug or get informations on your code based on information only collected for\r\na given user, a given context, a given procedure. A world where you can hunt weird and old code execution without even\r\n trying to update multiple and sparse PHP files, but just by adding advices on given conditions.\r\n\r\nWe are sure that this extension will soon be part of your future development workflow!\r\n\r\n[Latest version of the documentation](http://www.croes.org/gerald/projects/aop/documentation_aop_extension_php.pdf)","google":""}